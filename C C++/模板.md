---
title: 模板
aliases: 
author: SprInec
date: 2024-12-12
update: 2024-12-12 20:31:40
reference:
  - 黑马程序员C++教程
tags: cpp, 泛型编程
---
# 模板

### 1. 模板的概念

模板就是建立**通用的模具**，大大提高复用性。

模板的特点：
- 模板不可以直接使用，它只是一个模具
- 模板的通用性并不是万能的

### 2. 函数模板

- C++ 另一种编程思想为**泛型编程**，主要利用的技术就是模板
- C++ 提供两种模板机制
	- 函数模板
	- 类模板

#### 2.1 函数模板语法

函数模板的作用：建议一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个**虚拟的类型**来代表。

语法：
```cpp title:模板语法
template<typename T>
函数声明或定义
```

- `template` - 声明或创建模板
- `typename` - 表明其后面的字符是一种数据类型，可以用 `class` 代替
- `T` - 通用的数据类型，名称可以替换，通常为大写字母

```cpp title:利用模板实现变量交换 hl:1-7,15,18
template<typename T>
void userSwap(T &a, T &b)
{
	T temp = a;
	a = b;
	b = T;
}

void test_func()
{
	int a = 10;
	int b = 20;

	/* 1. 自动类型推导 */
	userSwap(a, b);

	/* 2. 显性指定类型 */
	userSwap<int>(a, b);
}
```

>[!Summary] 
> 
> - 函数模板利用关键字 `template`
> - 使用函数模板有两种方式：
> 	- 自动类型推导
> 	- 显性指定类型
> - 模板的目的是为了提高复用性，将类型参数化

#### 2.2 函数模板注意事项

1. 自动类型推导，必须推导出一致的数据类型 `T` ，才可以使用
2. 模板必须要确定出 `T` 的数据类型才可以使用

```cpp error:13,24 fix:25
template<class T>
void userSwap(T &a, T &b)
{
	T temp = a;
	a = b;
	b = temp;
}

void test_func1()
{
	int a = 10;
	char c = 'c';
	userSwap(a, c); // ⚠ ERROR: 数据类型不一致
}

template<class T>
void print_func()
{
	cout << "hello world" << endl;
}

void test_func2()
{
	print_func(); // ⚠ ERROR: 无法确定数据类型
	print_func<int>();
}
```

#### 2.3 普通函数与函数模板的区别

- 普通函数调用时可以发生自动类型转换（隐式类型转换）
- 函数模板调用时：
	- 如果利用自动类型推导，不会发生隐式类型转换
	- 如果利用显性指定类型的方式，可以发生隐式类型转换

#### 2.4 普通函数和函数模板的调用规则

1. 如果函数模板和普通函数都可以实现，优先调用普通函数
2. 可以通过空模板参数列表来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板

```cpp hl:1,6-7,13-14,25,28,36
void userPrint(int a, int b)
{
	cout << "Normal function" << endl;
}

template<typename T>
void userPrint(T a, T b)
{
	cout << "template function" << endl;
}

/* 3. 函数模板重载 */
template<typename T>
void userPrint(T a, T b, T c)
{
	cout << "template function" << endl;
}

void test_func()
{
	int a = 10;
	int b = 20;

	/* 1. 优先调用普通函数 */
	userPrint(a, b); // output: Normal function

	/* 2. 通过空模板参数列表强制调用函数模板 */
	userPrint<>(a, b); // output: template function

	userPrint(a, b ,100); // output: template function

	/* 4. 如果函数模板可以产生更好的匹配，优先调用函数模板 */
	char c = 'a';
	char d = 'b';

	userPrint(c, d); // output: template function
	
}
```

>[!Summary] 
> 
> 实际开发中，如果提供了函数模板，最好就不要提供普通函数，否则容易出现二义性

#### 2.5 模板的局限性

模板的通用性并不是万能的，有些特定的数据类型，需要用具体化的方式做特殊实现

```cpp hl:30
class Person
{
public:
	Person(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}

public:
	string m_name;
	int m_age;
};

template<typename T>
bool userCompare(T &a, T &b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

/* 💡利用具体化版本实现代码，具体化优先调用 */
/* 💡也可用运算符重载解决问题 */
template<> bool userCompare(Person &p1, Person &p2)
{
	if (p1.m_name == p2.m_name && p1.m_age == p2.m_age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void test_func()
{
	Person p1("Tom", 10);
	Person p2("Tom", 10);

	bool ret = userCompare(p1, p2);
	cout << ret << endl;
}
```

>[!Summary] 
> 
> - 利用具体化的模板，可以解决自定义类型的通用化
> - 学习模板并不是为了写模板，而是在 STL 中能够运用系统提供的模板

### 2. 类模板
#### 2.1 类模板语法

类模板作用：建立一个通用类，类中的成员数据类型可以不具体指定，用一个**虚构的类型**来代表。

语法：
```cpp
template<class T1, class T2, ...>
类定义
```

- `template` - 声明或创建模板
- `class` - 表明其后面的字符是一种数据类型，也可以用 `typename` 代替
- `T1,T2,...` - 通用的数据类型，名称可以替换，通常为大写字母

```cpp hl:1,22
template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	void print_content()
	{
		cout << m_name << m_age << endl;
	}
	
public:
	NameType m_name;
	AgeType m_age;
};

void test_func()
{
	Person<string, int> p("Mon", 19);
	p.print_content();
}
```

#### 2.2 类模板与函数模板的区别

1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

```cpp error:22 hl:5,23
template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age = int) // 可指定默认类型
	{
		this->m_name = name;
		this->m_age = age;
	}
	void print_content()
	{
		cout << m_name << m_age << endl;
	}
	
public:
	NameType m_name;
	AgeType m_age;
};

void test_func()
{
	Person p("Mon", 19); // ⚠ ERROR: 类模板不支持自动类型推导
	Person p("Mon");
	p.print_content();
}
```

>[!Summary] 
> 
> - 类模板使用时只能用显性指定类型的方式
> - 类模板中的模板参数列表可以有默认参数

#### 2.3 类模板中成员函数的创建时机

- 普通类中的成员函数一开始就可以创建
- 类模板中的成员函数在调用时才创建

```cpp
class Person
{
public:
	void showPerson1(){}
};
```